#!/bin/bash
#
# Functions called from other management scripts
#
# (c) Bruno Cornec <bruno.cornec@hpe.com>, Hewlett Packard Development
# (c) Frederic Passeron <frederic.passeron@hpe.com>, Hewlett Packard Development
#
# Released under the GPLv2 License
#
set -e
#set -x

# This function fetches an accessToken using user moderator credentials and open a session
get_session_token() {

	ret=`curl -s --location --request POST "$APIENDPOINT/login" \
			--header 'Content-Type: application/json' \
			--data "{\"username\":\"$APIUSER\",\"password\":\"$APIPWD\"}" | jq -r '.accessToken'`
        echo "$ret"

}


# This function returns the id number in the workshop DB when passed the workshop name
get_workshop_id() {

	id=0
	for i in `curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops" | jq -r '.[].id'`; do
		name=`curl -s --header "x-access-token:$accessToken"  --header "Content-Type: application/json" "$APIENDPOINT/workshops/$i" | jq .notebook | sed 's/"//g'`
		if [ _"$name" = _"$1" ]; then
			id=$i
			break

		fi
	done
	if [ $id = 0 ]; then
		echo "Workshop ID not found remotely for $1"
		exit -1
	fi
	echo "$id"
}

# This function exits when the student id is not in the correct range
teststdid() {
	
	# We need to ensure that we've got a correct id as parameter if needed
	MIN={{ USERMIN }}
	MAX={{ USERMAX }}

	if [ $1 -lt $MIN ] ||  [ $1 -gt $MAX ]; then
                echo "Student id ($1) should be between $MIN and $MAX"
                exit -1
        fi
}

# This function returns the status of the reset boolean for the workshop id given as parameter
get_reset_status() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.reset'`
	echo "$ret"
}

# This function returns the status of the beta  boolean for the workshop id given as parameter
get_beta_status() {

        ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.beta'`
        echo "$ret"
}

# This function returns the status of the need of LDAP setup for the workshop id given as parameter
get_ldap_status() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.ldap'`
	echo "$ret"
}


# This function returns the status of the need of Var Pass setup for the workshop id given as parameter
get_varpass_status() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.varpass'`
	echo "$ret"
}

# This function returns the status of the need of compiled scripts for the workshop id given as parameter
get_compile_status() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.compile'`
	echo "$ret"
}

# This function returns the min of the range of the users booked for the workshop id given as parameter
get_range_min() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.range[0]'`
	echo "$ret"
}

# This function returns the max of the range of the users booked for the workshop id given as parameter
get_range_max() {

	ret=`curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$APIENDPOINT/workshops/$1" | jq -r '.range[1]'`
	echo "$ret"
}

# This function creates a  GreenLake Central user using studentid and  password (stdid and randompwd) for GreenLake Based Workshops
create_greenlake_user() {

        # Get Studentid Group id API Call
        ret1=`curl -s --header "Authorization: {{ GREENLAKE_TOKEN }}" --header "Content-Type: application/json" '{{ GREENLAKE_API_URL }}/scim/v2/Groups?count=0&cursor=string&filter=displayName%20sw'"student$stdid" `
        echo "$ret1"

        # Create Studentxxx and Get glc_user_id API Call
        ret2=`curl -s --location --request POST --header "Authorization: {{ GREENLAKE_TOKEN }}" --header "Content-Type: application/json" \
                   --data "{ \"schemas\": [ [ \"urn:ietf:params:scim:schemas:core:2.0:User\", \"urn:ietf:params:scim:schemas:extensions:hpe-greenlake:2.0:UserCreate\" ] ], \"userName\": \"student$stdid\", \"password\": \"$randompw\", \"displayName\": \"student$stdid\", \"name\": { \"familyName\": \"student\", \"givenName\": \"$stdid\" }, \"emails\": [ { \"primary\": false, \"type\": \"SECONDARY\", \"value\": \"student$stdid@hpedev.io\" } ], \"urn:ietf:params:scim:schemas:extensions:hpe-greenlake:2.0:UserCreate\": { \"sendEmail\": true, \"changePassword\": true } }" '{{ GREENLAKE_API_URL }}/scim/v2/Users'  |jq -r '.id'`
        echo "$ret2"

        # Add Studentxxx  to Group Studentxxx using  glc_user_id  Group Studentxxx id  API Call
	ret3=`curl -s --location --request POST --header "Authorization: {{ GREENLAKE_TOKEN }}" --header "Content-Type: application/json" \
                   --data "{'userID': $ret2}" "{{ GREENLAKE_API_URL }}/iam/scim/v1/extensions/tenant/$ret1/Groups/$ret2/users"`
        echo "$ret3"

}
# This function deletes a  GreenLake Central user using studentid and  password (stdid and randompwd) for GreenLake Based Workshops
delete_greenlake_user() {

        # Get Studentid from student list
        ret1=`curl -s --header "Authorization: {{ GREENLAKE_TOKEN }}" --header "Content-Type: application/json" '{{ GREENLAKE_API_URL }}/scim/v2/Users?count=0&cursor=string&filter=userName%20sw'"student$stdid" `
        echo "$ret1"

        # Delete Studentid
        ret2=`curl -s --location --request POST --header "Authorization: {{ GREENLAKE_TOKEN }}" --header "Content-Type: application/json" "{{ GREENLAKE_API_URL }}/scim/v2/Users/$ret1"`
        echo "$ret2"
}


# This function updates the LDAP passwd with $randompw for the student under management (using $stdid)
update_ldap_passwd() {

	# define that variable to overload the student name (used by sec-student e.g.)
	if [ _"$LDAPSETUPUSER" = _"" ]; then
		LDAPSETUPUSER="student"
	fi
	rm -f /tmp/ldif.$$
	cat > /tmp/ldif.$$ << EOF
#modify user password
dn: uid=$LDAPSETUPUSER$stdid,ou=People,{{ LDAPDMN }}
changetype: modify
replace: userPassword
userPassword: $randompw
EOF
	ldapmodify -D "cn=Directory Manager" -w {{ LDAPPWD }} -p {{ LDAPPORT }} -h {{ LDAPSRV.split(' ')[1] }} -x -f /tmp/ldif.$$
	rm -f /tmp/ldif.$$
}

# This function creates a variable file in which password is stored from the ansible playbook with $randompw
create_var_passwd() {
  
	if [ ! -d "$JUPPROC/ansible-jupyter/$PBKDIR/pass" ]; then
		mkdir -p $JUPPROC/ansible-jupyter/$PBKDIR/pass
	fi
	ansible-vault encrypt_string --vault-password-file $JUPPROC/ansible-jupyter/vault_secret $randompw --name "'PASSSTU'" > $JUPPROC/ansible-jupyter/$PBKDIR/pass/variables_${w}_${stdid}.yml
}

# This function retuns the workshop name from the mail body
get_workshop_name() {

	read w
	if [ ! -n "$w" ]; then
		echo "Missing workshop name in the e-mail body"
		exit -1
	fi
	if [ ! -d "$std0/$w" ]; then
		echo "Non-existant workshop $w"
		exit -1
	fi
	echo "$w"
}

erase_student() {

	if [ _"$stddir" != _"" ]; then
		echo "Erasing target student dir $stddir content"
		sudo rm -rf $stddir/* $stddir/.??*
		sudo cp -a /etc/skel/.??* $stddir
		sudo chown -R student${stdid}:student${stdid} $stddir/.??*
		sudo chmod -R 600 $stddir/.ssh/*
        	sudo chmod 700 $stddir/.ssh
		echo "Create ssh keys to allow remote connections to appliance if needed"
		sudo su - student${stdid} -c "ssh-keygen -b 2048 -t rsa -f .ssh/id_rsa -N ''"
	fi
}

# This function creates a random password for a user, it is used for local and ldap users'passwords.
generate_randompwd() {

	if [ _"$RANDOMPW" != _"" ]; then
		export randompw=$RANDOMPW
	else
		export randompw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)
	fi
	echo "student$stdid:$randompw" | sudo chpasswd
}
