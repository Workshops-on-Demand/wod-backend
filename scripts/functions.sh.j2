#!/bin/bash
#
# Functions called from other management scripts
#
# (c) Bruno Cornec <bruno@hyper-linux.org>
# (c) Frederic Passeron <frederic.passeron@hpe.com>, Hewlett Packard Development
#
# Released under the GPLv2 License
#
set -e
#set -x

# Manages private functions
if [ -f {{ WODSCRIPTPRIVDIR }}/functions.sh ]; then
        source {{ WODSCRIPTPRIVDIR }}/functions.sh
fi

# This function fetches an accessToken using user moderator credentials and open a session
wod_get_session_token() {

	ret=`curl $WODCURLOPT -s --location --request POST "$WODAPIDBEXTURL/login" \
			--header 'Content-Type: application/json' \
			--data "{\"username\":\"$WODAPIDBUSER\",\"password\":\"$WODAPIDBUSERPWD\"}" | jq -r '.accessToken'`
        echo "$ret"
}


# This function returns the id number in the workshop DB when passed the workshop name
wod_get_workshop_id() {

	id=0
	id=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops" | jq -r '.[] | .notebook,.id' | grep -A 1 -E "^$1$" | tail -1`
	#for i in `curl -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops" | jq -r '.[].id'`; do
		#name=`curl -s --header "x-access-token:$accessToken"  --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$i" | jq .notebook | sed 's/"//g'`
		#if [ _"$name" = _"$1" ]; then
			#id=$i
			#break
		#fi
	#done
	if [ _"$id" = _"" ]; then
		echo "Workshop ID not found remotely for $1"
		exit -1
	fi
	echo "$id"
}

# This function exits when the student id is not in the correct range
wod_test_stdid() {
	
	# We need to ensure that we've got a correct id as parameter if needed
	MIN=$(({{ WODUSERMIN }}))
	MAX=$(({{ WODUSERMAX }}))

	if [ $1 -lt $MIN ] ||  [ $1 -gt $MAX ]; then
		echo "Student id ($1) should be between $MIN and $MAX"
		exit -1
	fi
}

# This function returns the status of the reset boolean for the workshop id given as parameter
wod_get_reset_status() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.reset'`
	echo "$ret"
}

# This function returns the status of the cleaned boolean for the user id given as parameter
wod_get_cleaned_status() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/customers/$1" | jq -r '.cleaned'`
	echo "$ret"
}

# This function waits in order to avoid concurrency with the CLEANUP phase
wod_wait_till_clean() {
	# Avoid concurrency with CLEANUP phase for 15' minutes max (step of 20")
	# based on the cleaned status of the customer whose user id given as parameter
	echo "Wait up to 15' using 20\" steps"
	cmax=45
	while [ _"`wod_get_cleaned_status $1`" != _"true" ] && [ $cmax -ge 0 ]; do
		cmax=$((cmax - 1))
		sleep 20
	done
	echo "End of wod_wait_till_clean (cmax: $cmax)"
}

# This function returns the status of the mono-appliance boolean for the workshop id given as parameter
wod_get_monoappliance_status() {

        ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.monoappliance'`
        echo "$ret"
}

# This function returns the status of the multi-appliance boolean for the workshop id given as parameter
wod_get_multiappliance_status() {

        ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.multiappliance'`
        echo "$ret"
}

# This function returns the status of the need of LDAP setup for the workshop id given as parameter
wod_get_ldap_status() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.ldap'`
	echo "$ret"
}


# This function returns the status of the need of Var Pass setup for the workshop id given as parameter
# it provides the PASSSTU variable through vault for the Notebook
wod_get_varpass_status() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.varpass'`
	echo "$ret"
}

# This function returns the status of the need of compiled scripts for the workshop id given as parameter
wod_get_compile_status() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.compile'`
	echo "$ret"
}

# This function returns the min of the range of the users booked for the workshop id given as parameter
wod_get_range_min() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.range[0]'`
	echo "$ret"
}

# This function returns the max of the range of the users booked for the workshop id given as parameter
wod_get_range_max() {

	ret=`curl $WODCURLOPT -s --header "x-access-token:$accessToken" --header "Content-Type: application/json" "$WODAPIDBEXTURL/workshops/$1" | jq -r '.range[1]'`
	echo "$ret"
}

# This function returns the base IP address of the appliance related to the workshop given as parameter
wod_get_appliance_baseip() {
	baseip=`grep IP-$1 {{ WODANSIBLEPRIVDIR }}/group_vars/{{ WODGROUP }} | cut -d: -f2 | sed 's/[ 	]*//'`
	if [ _"$baseip" = _"" ]; then
		baseip=`grep IP-$1 {{ WODANSIBLEDIR }}/group_vars/{{ WODGROUP }} | cut -d: -f2 | sed 's/[ 	]*//'`
		if [ _"$baseip" = _"" ]; then
			echo "Unable to find the appliance base IP for $1"
			exit -1
		fi
		if [ _"$baseip" = _"x.y.z.t" ]; then
			echo "Unable to find the correct appliance base IP for $1 - edit your conf file to change x.y.z.t and create the appliance"
			exit -1
		fi
	fi
	echo "$baseip"
}

# This function updates the LDAP passwd with $randompw for the student under management (using $stdid)
wod_update_ldap_passwd() {

	# define that variable to overload the student name (used by sec-student e.g.)
	if [ _"$WODLDAPSETUPUSER" = _"" ]; then
		WODLDAPSETUPUSER="student"
	fi
	rm -f /tmp/ldif.$$
	cat > /tmp/ldif.$$ << EOF

# modify user password
dn: uid=$WODLDAPSETUPUSER$stdid,ou=People,{{ WODLDAPDMN }}
changetype: modify
replace: userPassword
userPassword: $randompw
EOF
	ldapmodify -D "cn=Directory Manager" -w {{ WODLDAPPWD }} -p {{ WODLDAPPORT }} -h {{ WODLDAPSRVNAME }} -x -f /tmp/ldif.$$
	rm -f /tmp/ldif.$$
}

# This function creates a variable file in which password is stored from the ansible playbook with $randompw
wod_create_var_passwd() {
  
	if [ ! -d "{{ WODANSIBLEPRIVDIR }}/{{ WODGROUP }}/pass" ]; then
		mkdir -p "{{ WODANSIBLEPRIVDIR }}/{{ WODGROUP }}/pass"
	fi
	# It's now mandatory that vault_secret is located in the private part
	ansible-vault encrypt_string --vault-password-file "{{ WODANSIBLEPRIVDIR }}/vault_secret" $randompw --name "'PASSSTU'" > "{{ WODANSIBLEPRIVDIR }}/{{ WODGROUP }}/pass/variables_${w}_${stdid}.yml"
}

# This function retuns the workshop name from the mail body
wod_get_workshop_name() {

	read w
	if [ ! -n "$w" ]; then
		echo "Missing workshop name in the e-mail body"
		exit -1
	fi
	ws=`echo $w | sed 's/CHLG/WKSHP/'`
	if [ ! -d "{{ WODNOBO }}/$ws" ] && [ ! -d "{{ WODPRIVNOBO }}/$ws" ]; then
		echo "Non-existant workshop $ws"
		exit -1
	fi
	echo "$w"
}

wod_erase_student() {

	if [ _"$stddir" != _"" ]; then
		echo "Erasing target student dir $stddir content"
		sudo rm -rf $stddir/* $stddir/.??*
		sudo cp -a {{ WODINSDIR }}/../skel/.??* `find {{ WODPRIVDIR }}/skel -name '.??*'` $stddir
		sudo chown -R student${stdid}:student${stdid} $stddir/.??*
		echo "Create ssh keys to allow remote connections to appliance if needed"
		sudo su - student${stdid} -c "ssh-keygen -b 2048 -t rsa -f .ssh/id_rsa -N ''"
	fi
}

# This function creates a random password for a user, it is used for local and ldap users'passwords.
wod_generate_randompwd() {

	if [ _"$RANDOMPW" != _"" ]; then
		export randompw=$RANDOMPW
	else
		export randompw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)
	fi
	echo "student$stdid:$randompw" | sudo chpasswd
}


# This function calculates a completion ratio at the end of a  workshop-on-demand.
wod_get_completion_ratio() {

	cd $stddir/
	when=$(date +"%Y-%m-%d %H:%m:%S")
	what=$1
	who=student$stdid
	total=$(grep execution_count $what/*.ipynb  | wc -l)
	missed=$(grep execution_count $what/*.ipynb  | grep null | wc -l)
	done=$((total-missed))
	if [ $total -eq 0 ]; then
		completion=0
	else
		completion=$((done*100/total))
	fi
	#echo "date:$when,user:$who,workshop:$what,completion:$completion%"
	echo "$completion"
}


# Cleanup remaining processes for that student after the run
wod_cleanup_processes_student() {
	set +e
	ids=`ps auxww | grep /student$stdid | grep -v grep | awk '{ print $2 }'`
	if [ _"$ids" != _"" ]; then
		sudo kill $ids
		sleep 2
		sudo kill -9 $ids
	fi
	set -e
}
